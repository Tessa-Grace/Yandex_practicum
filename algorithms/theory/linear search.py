#________________________________________________________________________________________________
# Линейный проход по массиву
# _______________________________________________________________________________________________

# Последовательный перебор всех элементов называется «линейный проход по массиву», 
# а поиск, выполняемый путём линейного прохода, — «линейный поиск».
# При линейном поиске время выполнения программы напрямую зависит от длины массива, 
# по которому проводится поиск. Чем больше элементов в массиве, 
# тем больше операций в худшем случае надо выполнить и тем больше будет время работы алгоритма. 
# Такая зависимость времени выполнения от размера массива называется линейной, 
# а на графике выглядит как прямая линия.

def check_element_in_list(desired_element, ordered_list):
    """Проверяет наличие искомого элемента в отсортированном списке."""
    for item in ordered_list:
        if item < desired_element:
            continue
        if item == desired_element:
            return f'Элемент {desired_element} найден в массиве!'
        if item > desired_element:
            return f'Элемент {desired_element} не найден в массиве.'
            break
        
 
    return f'Элемент {desired_element} не найден в массиве.'


# Вызываем функцию с тестовыми данными.
# Первый аргумент - целое число.
# Второй аргумент - отсортированный по возрастанию список целых чисел.
result = check_element_in_list(5, [1, 3, 5, 7, 10])
# Распечатываем результат.
print(result)


# ________________________________________________________________________________________________
# Нахождение индекса первого вхождения искомого элемента в неотсортированном списке
# ________________________________________________________________________________________________

def find_element_index_in_unordered_list(desired_element, unordered_list):
    """
    Находит индекс первого вхождения искомого элемента 
    в неотсортированном списке.
    """
    # Применяем к списку функцию enumerate(), итерируемся
    # по полученному объекту enumerate и распаковываем его кортежи:
    # в переменную index сохраняем индекс элемента, в item - его значение.
    for index, item in enumerate(unordered_list):
        # Если значение текущего элемента равно искомому...
        if item == desired_element:
            # ...возвращаем его индекс:
            return index
    # Если цикл пройден, но нужное значение не найдено,
    # то возвращаем None. 
    # Явно возвращать None не обязательно, эту строку можно вообще не писать:
    # если в функции нет оператора return, она возвращает None.
    return None


wins = [7495938, 1223125, 2128437, 4567890, 2128500, 2741001, 9314543, 4567687]
my_ticket = 2128506
result = find_element_index_in_unordered_list(my_ticket, wins)
if result is not None:
    print(f'Индекс элемента {my_ticket} в массиве: {result}')
else:
    print(f'Элемент {my_ticket} не найден в массиве.')