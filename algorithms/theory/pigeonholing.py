"""
Голубиная сортировка.

Этот алгоритм похож на сортировку подсчётом: он тоже подсчитывает одинаковые значения и раскладывает их по ячейкам вспомогательной коллекции.
Голубиная сортировка работает не просто с массивом элементов, а с массивом структур данных (например, кортежей), которые надо отсортировать по ключу.
Своё название этот алгоритм получил от английского слова pigeonholing: pigeon — голубь, hole — нора, углубление, ячейка. 
Слово pigeonholing на русский можно примерно перевести как «навешивание ярлыков». Каждый голубь усаживается в свою ячейку, 
каждой вещи навешивается свой ярлык, как-то так.
При сортировке подсчётом мы создаём вспомогательную коллекцию длиной в весь диапазон возможных значений. 
Например, в массиве 1, 3, 100, 15 всего четыре элемента, а диапазон значений — от 0 до 100. 
И при сортировке подсчётом мы создадим вспомогательную коллекцию длиной во весь диапазон: в ней будет сто один элемент.
При голубиной сортировке тоже создаётся вспомогательная коллекция, но исходно в ней нет ни одного элемента. 
Алгоритм перебирает массив, предназначенный для сортировки, обнаруживает очередное уникальное значение — и создаёт для него новый элемент во вспомогательном массиве.

Задача — создать упорядоченный список шахматистов по убыванию рейтинга. Вводные данные такие:
Рейтинг — это целое положительное число, не превышающее 3000. Иными словами, количество уникальных значений в массиве r <= 3000.
Шахматистов, которым присвоен рейтинг, насчитывается более 350 тысяч. Это n.
Фактически требуется распределить 350 тысяч элементов в 3000 групп. 
Количество уникальных значений рейтинга нам известно — 3000, и относительно общего количества игроков это небольшое число. 
Эти условия вполне подходят для «голубиной сортировки».
Шаги сортировки будут состоять в следующем:
Представим, что у нас есть 3000 пустых списков, каждый список будет содержать шахматистов с определённым рейтингом. 
Реальный список будем создавать только когда попадётся шахматист с таким рейтингом.
Пройдёмся по общему списку шахматистов и каждого шахматиста добавим в тот список, который соответствует его рейтингу.
В конце пройдём по всем спискам в порядке убывания рейтингов (от 3000 к 1) и выпишем шахматистов из каждого очередного списка в результирующий массив.
Для каждого значения рейтинга мы собираем список шахматистов с этим рейтингом. При этом нет необходимости в попарном сравнении рейтингов.
Так мы получим упорядоченный список, причём сортировку можно сделать устойчивой. 
Для реализации сортировки импортируем тип данных defaultdict из модуля collections — это специальный словарь, элементам которого можно задать значение по умолчанию. 
При объявлении такого словаря можно указать тип данных, например — целое число:  defaultdict(int). Если обратиться к этому словарю по новому для него ключу, 
элемент с указанным ключом будет создан, а его значением будет 0.
В нашем решении значения словаря defaultdict должны хранить списки list: это будут списки кортежей — шахматистов с одинаковым рейтингом. 
Значения рейтинга будут ключами словаря.
При обращении к элементу словаря по ключу (значению рейтинга), которого еще нет в словаре, словарь вернёт пустой список — 
и в этот список можно будет добавить шахматистов с соответствующим рейтингом.
"""

from collections import defaultdict


def counting_sort(array, rating_max):
    # Шаг 1. Создаем словарь со значением по умолчанию: пустой список.
    rating_players = defaultdict(list)

    # Шаг 2. Раскладываем игроков в словарь, где ключами служат рейтинги,
    # а в качестве значений - списки игроков с таким рейтингом.
    for player, rating in array:
        rating_players[rating].append((player, rating))

    # Собираем отсортированный массив, перебирая рейтинги в порядке убывания.
    sorted_array = []
    for rating in range(rating_max, 0, -1):
        # Если в словаре рассматриваемый рейтинг непустой, то все шахматисты
        # с этим рейтингом добавляются в итоговый результат.
        if rating_players[rating]:
            sorted_array.extend(rating_players[rating])

    return sorted_array


chess_players = [
    ('Гукеш Доммараджу', 2758),
    ('Фабиано Каруана', 2786),
    ('Уэсли Со', 2753),
    ('Магнус Карлсен', 2839),
    ('Дин Лижэнь', 2780),
    ('Ян Непомнящий', 2771),
    ('Аниш Гири', 2760),
    ('Вишванатан Ананд', 2754),
    ('Алиреза Фирузджа', 2777),
    ('Хикару Накамура', 2780),
]
result = counting_sort(chess_players, 3000)
print(result)