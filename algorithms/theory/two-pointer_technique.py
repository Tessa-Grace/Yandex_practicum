"""
Метод двух указателей

Один из способов, позволяющих отбрасывать заведомо неподходящие варианты, — это метод двух указателей. 
Он применяется в ситуациях, когда данные хранятся в отсортированном массиве и необходимо найти в этом массиве значения, отвечающие определённым условиям, 
— например, заданную сумму двух элементов, как в приведённой задаче. Тем же методом можно найти, например, срез массива, где сумма значений будет равна заданному числу.
Для работы создаются два указателя: левый left_pointer и правый right_pointer. Каждый из указателей «наведён» на определённый элемент массива — хранит индекс этого элемента. 
В самом начале работы указатель left_pointer указывает на первый элемент массива, а right_pointer — на последний.

Алгоритм выполняется пошагово:
1. Установили указатели на определённые индексы.
2. Сравнили сумму значений элементов, на которые смотрят указатели.
3. В зависимости от результатов сравнения сдвинули один из указателей на один элемент ближе к середине массива.
4. Повторили все операции.
В ходе работы индекс левого указателя может только увеличиваться, а индекс правого — только уменьшаться; указатели смещаются навстречу друг другу, к середине массива. 
Отрезок массива, «зажатый» между указателями, с каждым шагом уменьшается. Значения, оказавшиеся вне этого отрезка, признаются «бесперспективными», отбрасываются.

Задача: возьмём предложенный в условии массив [1, 2, 3, 4, 5, 6, 7, 11] и искомую сумму 10.
В нашей задаче метод двух указателей работает так:
1. Если сумма двух элементов, на которые «смотрят» указатели, больше искомого значения, то сумму надо уменьшить (взять меньшее слагаемое). 
Сдвигаем правый указатель влево, уменьшая сумму.
2. Если сумма меньше искомого значения, сдвигаем левый указатель вправо, чтобы увеличить сумму значений.
3. Если указатели «встретились», у задачи нет решения. Один элемент нельзя использовать дважды, а при «встрече» оба указателя укажут на один элемент.
4. Если левый указатель окажется правее правого, он сам превратится в правый, и начнётся перебор уже рассмотренных вариантов. Такой вариант надо исключить.
"""

def find_two_indexes(data, expected_result):
    # В начале работы 
    # - левый указатель указывает на первый элемент списка (с индексом 0):
    left_pointer = 0
    # - правый указатель указывает на последний элемент; 
    # индекс этого элемента на единицу меньше длины списка.
    right_pointer = len(data) - 1
    # Пока индекс левого указателя меньше индекса правого указателя.
    while left_pointer < right_pointer:
        # Считаем сумму двух элементов.
        result = data[left_pointer] + data[right_pointer]
        # Если она совпадает с искомой...
        if result == expected_result:
            # ...возвращаем ответ:
            return left_pointer, right_pointer
        # Если сумма больше искомой, то...
        if result > expected_result:
            # ...надо уменьшить сумму: уменьшаем значение правого указателя.
            right_pointer -= 1
        # Все остальные варианты относятся к случаям, когда сумма меньше искомой. 
        else:
            # Сумму надо увеличить, для этого увеличиваем значение левого указателя.
            left_pointer += 1


if __name__ == '__main__':
    data = [1, 2, 3, 4, 5, 6, 7, 11]
    expected_result = 10
    print(find_two_indexes(data, expected_result))