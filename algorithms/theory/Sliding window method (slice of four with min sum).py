"""
Метод скользящего окна

Это алгоритмический подход, который используется для эффективного решения задач, связанных с обработкой последовательностей (массивов, строк и т. д.). 
Он особенно полезен, когда нужно найти подмассив или подстроку, удовлетворяющую определённым условиям (например, максимальную сумму подмассива, подстроку без повторяющихся символов и т. д.).
- "Окно" — это непрерывный подмассив или подстрока фиксированного или переменного размера.
- "Скольжение" — это перемещение окна по последовательности шаг за шагом, без пересчёта всей информации заново.

Когда применяется?
1. Задачи на подмассивы/подстроки с условиями (сумма, уникальность символов и т. д.).
2. Когда можно переиспользовать вычисления предыдущего шага (оптимизация с O(n²) до O(n)).
Обычно этот метод применяется для поиска заданного среза или какого-то значения, вычисленного на основе элементов среза: 
можно искать минимальную сумму (как в нашей задаче), можно заданную сумму или среднее значение сумм. 

Для массива, состоящего из n целых чисел, найдите непрерывный подмассив (срез) заданной длины k, сумма значений в котором минимальна. Напечатайте эту сумму.
Число k всегда больше нуля и меньше n.
Например, даны:
список [5, -3, -2, 10, 2, 7, 1, -6, 13],
длина подмассива k = 4.
Требуется найти такой срез из четырёх элементов, в котором сумма значений будет минимальна.

"""
# _______________________________________________________________________________________________
# Наивный способ (без метода скользящего окна)
# _______________________________________________________________________________________________
from sys import maxsize


def find_min_slice_sum(data, elements_in_slice):
    min_sum = maxsize
    for index in range(len(data) - elements_in_slice + 1):
        # Вместо внутреннего цикла считаем сумму нужного среза.
        temp_sum = sum(data[index:index+elements_in_slice])
        min_sum = min(min_sum, temp_sum)
    return min_sum


if __name__ == '__main__':
    data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
    elements_in_slice = 4
    print(find_min_slice_sum(data, elements_in_slice))



# _______________________________________________________________________________________________
# Решение методом скользящего окна
# _______________________________________________________________________________________________

def find_min_slice_sum(data, elements_in_slice):
    # Считаем сумму первого окна.
    window_sum = sum(data[0:elements_in_slice])
    # Запоминаем результат подсчёта в качестве минимальной суммы.
    min_sum = window_sum
    # В цикле перебираем индексы массива от elements_in_slice до последнего.
    for index in range(elements_in_slice, len(data)):
        # К сумме предыдущего окна добавляем новый элемент: data[index]
        # и вычитаем "вышедший" элемент: data[index - elements_in_slice]
        window_sum += data[index] - data[index - elements_in_slice]
        # Находим минимальную сумму.
        min_sum = min(min_sum, window_sum)
    return min_sum


if __name__ == '__main__':
    data = [5, -3, -2, 10, 2, 7, 1, -6, 13]
    elements_in_slice = 4
    print(find_min_slice_sum(data, elements_in_slice))