#________________________________________________________________________________________________
# Бинарный поиск по массиву
# _______________________________________________________________________________________________

# Алгоритм бинарного поиска предназначен для обнаружения целевого значения в отсортированном массиве. 
# В процессе поиска целевое значение сравнивается с элементом в середине массива. Если значения не равны, 
# половина, в которой искомый элемент не может находиться, больше не рассматривается, 
# и поиск продолжается во второй половине: снова берётся средний элемент и сравнивается с целевым значением. 
# Операция повторяется до тех пор, пока целевое значение не будет найдено. 
# Если в конце поиска оставшаяся половина оказывается пустой, значит, цель отсутствует в массиве.

# Логарифмическая зависимость времени от длины массива
# Чтобы определить количество операций, необходимых при бинарном поиске в массиве длиной n, надо узнать, 
# в какую степень нужно возвести двойку, чтобы получить n или ближайшее к n число, большее, чем n. 
# В математике эта операция называется логарифмом. Записывается логарифм так: log b (a).
# При бинарном поиске число операций логарифмически зависит от длины массива, в котором ведётся поиск. 

wins = ['алгоритмы', 'будут', 'главным', 'доводом', 'профессионального', 'разработчика']


def find_element(sorted_numbers, element):
    """Находит индекс element в отсортированном списке sorted_numbers."""
    # Левая граница (левый индекс) рассматриваемого набора элементов. 
    # В начале работы она равна индексу первого элемента в списке.
    left = 0
    # Правая граница (правый индекс) рассматриваемого набора элементов. 
    # В начале работы она равна длине списка.
    right = len(sorted_numbers)
    # Допишите код, реализующий бинарный поиск.
    # За основу можно взять код из предыдущего примера.
    while left < right:
        mid = (left + right) // 2
        if sorted_numbers[mid] == element:
            return mid
        if sorted_numbers[mid] < element:
            left = mid + 1
        else:
            right = mid
    return None



# Проверим, что ваш код успешно находит все значения,
# которые есть в списке wins: в качестве искомого элемента
# поочерёдно передадим в функцию все значения из списка.
for item in wins:
    print(find_element(wins, 'главным'))